// RISC32 CPU 分支与跳转指令测试文件（完全修正版）
// 使用正确的指令编码和跳转地址

// ===================== 初始化和寄存器设置 =====================
00100093 // [0x00000000] addi x1, x0, 1   ; x1 = 1
00200113 // [0x00000004] addi x2, x0, 2   ; x2 = 2
00300193 // [0x00000008] addi x3, x0, 3   ; x3 = 3
00400213 // [0x0000000C] addi x4, x0, 4   ; x4 = 4
00100293 // [0x00000010] addi x5, x0, 1   ; x5 = 1 (用于相等比较)
fff00313 // [0x00000014] addi x6, x0, -1  ; x6 = 0xFFFFFFFF
00100393 // [0x00000018] addi x7, x0, 1   ; x7 = 1

// ===================== B类型指令测试 =====================
// 注意：立即数字段是2字节对齐的，实际编码 = 偏移量 << 1

// 测试1: beq (相等时跳转) - 应该跳转
00508463 // [0x0000001C] beq x1, x5, 8    ; x1(1)==x5(1) 跳转到0x1C+8=0x24
00100113 // [0x00000020] addi x2, x0, 1   ; 不应该执行
00200113 // [0x00000024] addi x2, x0, 2   ; 应该执行: x2=2
00100193 // [0x00000028] addi x3, x0, 1   ; 继续: x3=1

// 测试2: beq (不相等时不跳转)
00208463 // [0x0000002C] beq x1, x2, 8    ; x1(1)!=x2(2) 不跳转
00300113 // [0x00000030] addi x2, x0, 3   ; 应该执行: x2=3
00100213 // [0x00000034] addi x4, x0, 1   ; 继续: x4=1

// 测试3: bne (不相等时跳转) - 应该跳转
00209463 // [0x00000038] bne x1, x2, 8    ; x1(1)!=x2(3) 跳转到0x38+8=0x40
00400113 // [0x0000003C] addi x2, x0, 4   ; 不应该执行
00500113 // [0x00000040] addi x2, x0, 5   ; 应该执行: x2=5
00100293 // [0x00000044] addi x5, x0, 1   ; 继续: x5=1

// 测试4: bne (相等时不跳转)
00509463 // [0x00000048] bne x1, x5, 8    ; x1(1)==x5(1) 不跳转
00600113 // [0x0000004C] addi x2, x0, 6   ; 应该执行: x2=6
00100313 // [0x00000050] addi x6, x0, 1   ; 继续: x6=1

// 测试5: blt (小于时跳转) - 应该跳转
// 注意：现在x1=1, x2=6，所以1<6成立
0020c463 // [0x00000054] blt x1, x2, 8    ; x1(1)<x2(6) 跳转到0x54+8=0x5C
00700113 // [0x00000058] addi x2, x0, 7   ; 不应该执行
00800113 // [0x0000005C] addi x2, x0, 8   ; 应该执行: x2=8
00100393 // [0x00000060] addi x7, x0, 1   ; 继续: x7=1

// 测试6: blt (不小于时不跳转)
0011c463 // [0x00000064] blt x3, x1, 8    ; x3(1)>=x1(1) 不跳转
00900113 // [0x00000068] addi x2, x0, 9   ; 应该执行: x2=9
00100413 // [0x0000006C] addi x8, x0, 1   ; 继续: x8=1

// 测试7: bge (大于等于时跳转) - 应该跳转
0010d463 // [0x00000070] bge x1, x1, 8    ; x1(1)>=x1(1) 跳转到0x70+8=0x78
00a00113 // [0x00000074] addi x2, x0, 10  ; 不应该执行
00b00113 // [0x00000078] addi x2, x0, 11  ; 应该执行: x2=11
00100493 // [0x0000007C] addi x9, x0, 1   ; 继续: x9=1

// 测试8: bge (小于时不跳转)
0020d463 // [0x00000080] bge x1, x2, 8    ; x1(1)<x2(11) 不跳转
00c00113 // [0x00000084] addi x2, x0, 12  ; 应该执行: x2=12
00100513 // [0x00000088] addi x10, x0, 1  ; 继续: x10=1

// 测试9: bltu (无符号小于时跳转) - 应该跳转
// 重新设置x6为-1 (0xFFFFFFFF)
fff00313 // [0x0000008C] addi x6, x0, -1  ; x6 = 0xFFFFFFFF
0060e463 // [0x00000090] bltu x1, x6, 8   ; 1 < 0xFFFFFFFF 跳转到0x90+8=0x98
00d00113 // [0x00000094] addi x2, x0, 13  ; 不应该执行
00e00113 // [0x00000098] addi x2, x0, 14  ; 应该执行: x2=14
00100593 // [0x0000009C] addi x11, x0, 1  ; 继续: x11=1

// 测试10: bltu (无符号不小于时不跳转)
00136463 // [0x000000A0] bltu x6, x1, 8   ; 0xFFFFFFFF >= 1 不跳转
00f00113 // [0x000000A4] addi x2, x0, 15  ; 应该执行: x2=15
00100613 // [0x000000A8] addi x12, x0, 1  ; 继续: x12=1

// 测试11: bgeu (无符号大于等于时跳转) - 应该跳转
00137463 // [0x000000AC] bgeu x6, x1, 8   ; 0xFFFFFFFF >= 1 跳转到0xAC+8=0xB4
01000113 // [0x000000B0] addi x2, x0, 16  ; 不应该执行
01100113 // [0x000000B4] addi x2, x0, 17  ; 应该执行: x2=17
00100693 // [0x000000B8] addi x13, x0, 1  ; 继续: x13=1

// 测试12: bgeu (无符号小于时不跳转)
0060f463 // [0x000000BC] bgeu x1, x6, 8   ; 1 < 0xFFFFFFFF 不跳转
01200113 // [0x000000C0] addi x2, x0, 18  ; 应该执行: x2=18
00100713 // [0x000000C4] addi x14, x0, 1  ; 继续: x14=1

// B类型指令测试完成
// 此时x2应该为18，其他寄存器x3-x14应该为1

